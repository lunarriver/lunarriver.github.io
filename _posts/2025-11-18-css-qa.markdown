---
layout: post
title:  "CSS Q&A"
date:   2025-11-18 15:16:00 +0800
---

* 目录
  {:toc #markdown-toc}

### 盒模型

当对一个文档进行布局（lay out）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）。CSS 决定这些盒子的大小、位置以及属性（例如颜色、背景、边框尺寸…）。

每个盒子由四个部分（或称区域）组成，其效用由它们各自的边界（Edge）所定义。每个盒子有四个边界：

- 内容边界 Content edge

- 内边距边界 Padding Edge

- 边框边界 Border Edge

- 外边框边界 Margin Edge

**内容区域（content area）**

由内容边界限制，容纳着元素的“真实”内容，例如文本、图像，或是一个视频播放器。它的尺寸为内容宽度（或称 content-box 宽度）和内容高度（或称 content-box 高度）。

如果 box-sizing 为 content-box（默认），则内容区域的大小可明确地通过 width、min-width、max-width、height、min-height 和 max-height 控制。

它通常含有一个背景颜色（默认颜色为透明）或背景图像。

**内边距区域（padding area）**

由内边距边界限制，扩展自内容区域，负责延伸内容区域的背景，填充元素中内容与边框的间距。它的尺寸是 padding-box 宽度 和 padding-box 高度。内边距的粗细可以由 padding-top、padding-right、padding-bottom、padding-left，和简写属性 padding 控制。

**边框区域（border area）**

由边框边界限制，扩展自内边距区域，是容纳边框的区域。其尺寸为 border-box 宽度和 border-box 高度。边框的粗细由 border-width 和简写的 border 属性控制。

如果 box-sizing 属性被设为 border-box，那么边框区域的大小可明确地通过 width、min-width, max-width、height、min-height，和 max-height 属性控制。

假如框盒上设有背景（background-color 或 background-image），背景将会一直延伸至边框的外沿（默认为在边框下层延伸，边框会盖在背景上）。此默认表现可通过 CSS 属性 background-clip 来改变。

**外边距区域（margin area）**

由外边距边界限制，用空白区域扩展边框区域，以分开相邻的元素。它的尺寸为 margin-box 宽度和 margin-box 高度。

外边距区域的大小由 margin-top、margin-right、margin-bottom、margin-left，和简写属性 margin 控制。在发生外边距合并的情况下，由于盒之间共享外边距，外边距不容易弄清楚。

### 外边距折叠

区块的上下外边距有时会合并（折叠）为单个边距，其大小为两个边距中的最大值（或如果它们相等，则仅为其中一个），这种行为称为外边距折叠。

有三种情况会形成外边距折叠：

**相邻的兄弟元素**

```
<div class="box1">Box 1</div>
<div class="box2">Box 2</div>

.box1 { margin-bottom: 20px; }
.box2 { margin-top: 30px; }
```

预期间距：20 + 30 = 50px

实际间距：30px（取较大值）

**父元素与第一个/最后一个子元素**

```
<div class="parent">
  <div class="child">Child</div>
</div>

.parent { margin-top: 20px; }
.child  { margin-top: 30px; }
```

如果 .parent 没有边框、内边距、行内内容、创建 BFC，则父子 margin 会折叠。

结果：.parent 外部看起来有 30px 上边距（不是 20px，也不是 50px）。

**空块级元素**

```
<div style="margin-top: 20px; margin-bottom: 30px;"></div>
```

该元素无内容、无 padding、无 border，上下 margin 折叠，实际高度为 30px（取大值）。

什么情况下不会发生外边距折叠？

| 条件                          | 说明                                                                     |
| --------------------------- | ---------------------------------------------------------------------- |
| **存在 border 或 padding**     | 父元素有`border-top`或`padding-top`，可阻止与子元素的 margin 折叠                      |
| **创建了 BFC（块格式化上下文）**        | 如`overflow: hidden`、`display: flow-root`、`float`、`position: absolute`等 |
| **元素是 flex 或 grid 容器的直接子项** | Flex/Grid 布局中，子项的 margin**不会折叠**                                       |
| **水平方向 margin**             | `margin-left`/`margin-right`永远不折叠                                      |
| **使用`gap`的现代布局**            | Flex/Grid 中用`gap`替代 margin，避免问题                                        |

### BFC

BFC（Block Formatting Context，块级格式化上下文） 是 Web 布局中的一个核心概念，它是一个独立的渲染区域，内部的元素布局不会影响外部，外部的布局也不会干扰内部。

可以把它理解为页面中的一个“隔离沙盒”——在这个沙盒里，元素按照自己的规则排版，与外界互不干扰。

BFC 主要解决以下常见布局问题：

| 问题                         | BFC 如何解决                 |
| -------------------------- | ------------------------ |
| **外边距折叠（Margin Collapse）** | BFC 内部的 margin 不会与外部元素折叠 |
| **浮动元素导致父容器高度塌陷**          | BFC 容器会包含浮动子元素，计算高度时将其纳入 |
| **文字环绕浮动元素**               | BFC 区域不会与浮动元素重叠，形成“避让”   |

只要满足以下任一条件，元素就会创建一个新的 BFC：

| 触发方式                                                                            | 示例                                 |
| ------------------------------------------------------------------------------- | ---------------------------------- |
| `float`不为`none`                                                                 | `float: left`                      |
| `position`为`absolute`或`fixed`                                                   | `position: absolute`               |
| `display`为`inline-block`、`table-cell`、`table-caption`、`flex`、`grid`、`flow-root` | `display: flow-root`（推荐）           |
| `overflow`不为`visible`                                                           | `overflow: hidden`/`auto`/`scroll` |
| `contain`为`layout`、`content`、`paint`等                                           | `contain: layout`                  |

### css 尺寸单位

CSS 中的尺寸单位用于定义长度、宽度、间距、字体大小等。它们分为 绝对单位、相对单位 和 特殊单位 三大类。

**绝对单位（Absolute Units）**

适用于物理尺寸固定的场景（如打印样式），但在屏幕显示中不推荐用于布局，因为无法适配不同设备。

| 单位   | 含义                       | 示例                       |
| ---- | ------------------------ | ------------------------ |
| `px` | 像素（CSS 像素，非物理像素）         | `font-size: 16px;`       |
| `in` | 英寸（1in = 96px）           | `margin: 1in;`           |
| `cm` | 厘米（1cm ≈ 37.8px）         | `width: 10cm;`           |
| `mm` | 毫米                       | `height: 50mm;`          |
| `pt` | 点（1pt = 1/72in ≈ 1.33px） | 常用于打印：`font-size: 12pt;` |

`px`虽是“绝对单位”，但现代浏览器会根据设备像素比（DPR）进行缩放，并非真正的物理像素。

**相对单位（Relative Units）**

相对于字体大小：

| 单位    | 相对于                           | 特点               |
| ----- | ----------------------------- | ---------------- |
| `em`  | **当前元素的`font-size`**          | 可继承、可级联（嵌套时会放大）  |
| `rem` | **根元素（`<html>`）的`font-size`** | 不受嵌套影响，推荐用于布局和间距 |

相对于视口：

| 单位     | 含义             | 适用场景       |
| ------ | -------------- | ---------- |
| `vw`   | 视口宽度的 1%       | 全屏横幅、响应式宽度 |
| `vh`   | 视口高度的 1%       | 全屏容器、英雄区域  |
| `vmin` | `vw`和`vh`中的较小值 | 正方形响应式元素   |
| `vmax` | `vw`和`vh`中的较大值 | 大屏适配       |

相对于父容器：

| 单位   | 含义                      | 说明                                |
| ---- | ----------------------- | --------------------------------- |
| `%`  | 父元素对应尺寸的百分比             | `width: 50%`= 父容器宽度的一半            |
| `fr` | **Grid 布局专用**，表示剩余空间的比例 | `grid-template-columns: 1fr 2fr;` |

**特殊单位与函数**

calc() —— 动态计算

```
.width {
  width: calc(100% - 40px); /* 百分比减去固定值 */
  font-size: calc(1rem + 0.5vw); /* 响应式字体 */
}
```

clamp() —— 响应式范围限制

```
h1 {
  font-size: clamp(1.5rem, 4vw, 3rem);
  /* 最小 1.5rem，理想 4vw，最大 3rem */
}
```

min() / max()

```
.container {
  width: min(80%, 800px); /* 取较小值 */
  padding: max(1rem, 2vw); /* 取较大值 */
}
```

### 元素堆叠

**堆叠时不使用 z-index 属性**

当没有在任何元素上指定 z-index 属性时，元素的堆叠顺序如下（从下到上）：

- 根元素的背景和边框

- 后代非定位元素，按在 HTML 中出现的顺序排列

- 后代定位元素，按在 HTML 中出现的顺序排列

![img](../../../assets/css-qa/element-pile-1.png)

**层叠与浮动**

浮动块元素被放置于非定位块元素与定位块元素之间：

- 根元素的背景和边框

- 后代非定位元素，按在 HTML 中出现的顺序排列

- 浮动块元素

- 后代定位元素，按在 HTML 中出现的顺序排列

![img](../../../assets/css-qa/element-pile-2.png)

**使用 z-index**

z-index 必须是整数 (正负均可，默认为0)，它体现了元素在 z 轴的位置。z 轴上的每个层都有一个顺序数，顺序数大的层在上面，小的在下面。

- z-index 只对指定了 positioned 属性的元素有效。

- 当没有指定 z-index 的时候，所有元素都在会被渲染在默认层（0 层）。

- 当多个元素的 z-index 属性相同的时候（在同一个层里面），那么将按照“堆叠时不使用 z-index 属性”中描述的规则进行布局。

**层叠上下文**

层叠上下文指的是：元素按照默认顺序堆叠，或依据 z-index 值堆叠的上下文元素。在同个上下文下，默认规则起作用。重要的是，其子级层叠上下文的 z-index 值只在父级中才有意义。子级层叠上下文被自动视为父级层叠上下文的一个独立单元。

- 层叠上下文可以包含在其他层叠上下文中，并且一起创建一个层叠上下文的层级。 

- 每个层叠上下文都完全独立于它的兄弟元素：当处理层叠时只考虑子元素。 

- 每个层叠上下文都是自包含的：当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠。

文档中的层叠上下文由满足以下任意一个条件的元素形成：

- 文档根元素（<html>）；

- position 值为 absolute（绝对定位）或 relative（相对定位）且 **z-index 值不为 auto** 的元素；

- position 值为 fixed（固定定位）或 sticky（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；

- flex (flex) 容器的子元素，且 z-index 值不为 auto；

- grid (grid) 容器的子元素，且 z-index 值不为 auto；

- opacity 属性值小于 1 的元素（参见 the specification for opacity）；

- mix-blend-mode 属性值不为 normal 的元素；

- 特定属性值不为 none 的元素： transform、filter、backdrop-filter、perspective、clip-path、mask / mask-image / mask-border；（以及 isolation 属性值为 isolate 的元素）

- will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素（参考这篇文章）；

- contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。

**根元素作为层叠上下文**

![img](../../../assets/css-qa/element-pile-3.png)

![img](../../../assets/css-qa/element-pile-4.png)

![img](../../../assets/css-qa/element-pile-5.png)

该示例中，DIV #1 和 DIV #3 没有设置 z-index 的值，所以它们不会创建层叠上下文。这就意味着 DIV #1 和 DIV #3 的所有内容（包括 DIV #2 和 DIV #4）都属于同一个层叠上下文（即根元素的层叠上下文）。

**创建层叠上下文**

![img](../../../assets/css-qa/element-pile-6.png)

该示例中，DIV #2 (z-index: 2) 在 DIV #4 (z-index: 10) 的上面，尽管 DIV #2 的 z-index 值小于 DIV #4。原因在于它们不属于同一个层叠上下文。DIV #4 处于 DIV #3 所创建的层叠上下文中，而整个 DIV #3（包含其后代元素）是在 DIV #2 下面的。

![img](../../../assets/css-qa/element-pile-7.png)

该示例中，一级菜单仅仅是相对定位，所以没有创建层叠上下文。

二级菜单相对其父元素（一级菜单）绝对定位，要使二级菜单在所有一级菜单的上方，则需要使用 z-index。此时每个二级菜单都创建了一个层叠上下文，而三级菜单也处于其父元素（二级菜单）创建的上下文中。

这样一来，在 HTML 结构中处于三级菜单后面的二级菜单，则会显示在三级菜单的上方，因为所有的二级菜单都使用了同样的 z-index 值，所以处于同一个层叠上下文中。

### display: inline-block

display: inline-block 是 CSS 中一个非常实用的布局属性值，它结合了 inline（内联）和 block（块级）元素的特性，常用于需要“水平排列 + 设置宽高”的场景。

| 属性                    | `display: inline` | `display: inline-block` | `display: block` |
| --------------------- | ----------------- | ----------------------- | ---------------- |
| 是否独占一行                | 否                 | 否                       | 是                |
| 能否设置宽高                | 不能（忽略）            | 能                       | 能                |
| 能否设置上下 margin/padding | 可设但不影响布局（垂直方向无效）  | 完全有效                    | 完全有效             |
| 内容是否换行                | 是（文本流）            | 否（默认）                   | 是                |

### css 选择器

**伪类**

伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。

例如，:hover伪类会在鼠标指针悬浮到一个元素上的时候选择这个元素：

```
a:hover { }
```

注意，`article p:first-child` 选中的是 <article> 下第一个 <p>，而不是 <p> 下的第一个元素。

```
article p:first-child {
  font-size: 120%;
  font-weight: bold;
}
```

**伪元素**

伪元素以类似方式表现。不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。

例如，::first-line是会选择一个元素（下面的情况中是<p>）中的第一行：

```
p::first-line { }
```

**关系选择器**

后代选择器通常用单个空格字符来组合两个选择器。当第二个选择器匹配的元素存在一个祖先元素（父元素、祖父元素等）与第一个选择器匹配时，该元素就会被选中。

```
body article p
```

子代关系选择器是个大于号（>），只会在选择器选中直接子元素的时候匹配。继承关系上更远的后代则不会匹配。

```
article > p
```

邻接兄弟选择器（+）用来选中恰好处于另一个在继承关系上同级的元素旁边的物件。例如，选中所有紧随<p>元素之后的<img>元素：

```
p + img
```

如果你想选中一个元素的兄弟元素，即使它们不直接相邻，你还是可以使用通用兄弟关系选择器（~）。要选中所有的<p>元素后任何地方的<img>元素，我们会这样做：

```
p ~ img
```

### 渐变

渐变类型：

- 线性渐变会在一个假想的直线上过渡颜色。线性渐变是由 linear-gradient() 函数产生的。

- 径向渐变从一个中间点（原点）开始过渡颜色。径向渐变是由 radial-gradient() 函数产生的。

- 重复渐变可根据需要复制渐变，以填充指定区域。重复渐变是使用 repeating-linear-gradient() 和 repeating-radial-gradient() 函数生成的。

- 锥形渐变会沿着一个圆过渡颜色。锥形渐变是由 conic-gradient() 函数产生的。

![img](../../../assets/css-qa/gradient.png)

### 布局

**浮动**

把一个元素“浮动”(float) 起来，会改变该元素本身和在正常布局流（normal flow）中跟随它的其他元素的行为。这一元素会浮动到左侧或右侧，并且从正常布局流 (normal flow) 中移除，这时候其他的周围内容就会在这个被设置浮动 (float) 的元素周围环绕。

![img](../../../assets/css-qa/float.png)

当一个容器只包含浮动元素时，它的高度会变成 0（高度塌陷），影响后续布局。

```
<div class="parent">
  <div style="float: left;">Item 1</div>
  <div style="float: left;">Item 2</div>
</div>
<!-- .parent 高度为 0！ -->
```

clear 属性可用于阻止元素与浮动元素在同一行显示。

```
.clear-left  { clear: left; }
.clear-right { clear: right; }
.clear-both  { clear: both; } /* 最常用 */
```

另外，通过触发父容器形成 BFC，使其包含浮动子元素。

```
.parent {
  display: flow-root; /* 最新标准，专为解决此问题设计 */
}
```

**定位**

定位 (positioning) 能够让我们把一个元素从它原本在正常布局流 (normal flow) 中应该在的位置移动到另一个位置。

- 静态定位（Static positioning）是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。

- 相对定位（Relative positioning）允许我们相对于元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计（design pinpointing）非常有用。

- 绝对定位（Absolute positioning）将元素完全从页面的正常布局流（normal layout flow）中移出，类似将它单独放在一个图层中。我们可以将元素相对于页面的 <html> 元素边缘固定，或者相对于该元素的最近被定位祖先元素（nearest positioned ancestor element）。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板。

- 固定定位（Fixed positioning）与绝对定位非常类似，但是它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。这在创建类似在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时非常有用。

- 粘性定位（Sticky positioning）是一种新的定位方式，它会让元素先保持和 position: static 一样的定位，当它的相对视口位置（offset from the viewport）达到某一个预设值时，它就会像 position: fixed 一样定位。

### 媒体查询

CSS 媒体查询为你提供了一种应用 CSS 的方法，仅在浏览器和设备的环境与你指定的规则相匹配的时候 CSS 才会真的被应用，例如“视口宽于 480 像素”的时候。

最简单的媒体查询语法看起来是像这样的：

```
@media media-type and (media-feature-rule) {
  /* CSS rules go here */
}
```

它由以下部分组成：

- 一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）；

- 一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试；

- 一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。

**媒体类型**

可以指定的媒体类型为：all、print、screen、speech。

- all：适用于所有设备。

- print：适用于打印预览和实际打印时的页面。

- screen：适用于彩色屏幕设备，如电脑显示器、手机、平板等。

- speech：适用于语音合成器（screen readers） 等语音输出设备。（为视障用户提供语音阅读支持）

**媒体特征规则**

为了建立响应式设计（已经广受浏览器支持），我们一般最常探测的特征是视口宽度，而且我们可以使用min-width、max-width和width媒体特征，在视口宽度大于或者小于某个大小——或者是恰好处于某个大小——的时候，应用 CSS。

```
@media screen and (max-width: 400px) {
  body {
    color: blue;
  }
}
```

一个受到良好支持的媒体特征是orientation，我们可以用它测得竖放（portrait mode）和横放（landscape mode）模式。

```
@media (hover: hover) {
  body {
    color: rebeccapurple;
  }
}
```

### css 预处理器

CSS 预处理器（CSS Preprocessor）是一种扩展了 CSS 语法的编程语言，它引入了变量、嵌套、混合（mixin）、函数、条件判断、循环等编程特性，让 CSS 更具可维护性、模块化和逻辑性。预处理器代码不能被浏览器直接识别，必须先编译成标准 CSS，才能在网页中使用。

原生 CSS 存在以下痛点：

- 无法定义变量 → 颜色、间距重复写，修改困难

- 不支持嵌套 → 选择器冗长，结构不清晰

- 无法复用代码块（如按钮样式）

- 没有逻辑控制（if/else、for 循环）

主流 CSS 预处理器对比：

| 特性            | **Sass / SCSS**                                            | **Less**                                      | **Stylus**                                |
| ------------- |------------------------------------------------------------| --------------------------------------------- | ----------------------------------------- |
| **语法风格**      | `.scss`（类 CSS）或`.sass`（缩进式）                                | 类 CSS                                         | 灵活（可省略大括号、分号）                             |
| **流行度**       | （最主流）                                                      | /                                             | /                                         |
| **变量**        | `$primary: #333;`                                          | `@primary: #333;`                             | `primary = #333`                          |
| **嵌套**        | 支持                                                         | 支持                                            | 支持                                        |
| **Mixin**（混入） | `@mixin button($color) { ... }`<br>`@include button(blue);` | `.button(@color) { ... }`<br>`.button(blue);` | `button(color) { ... }`<br>`button(blue)` |
| **继承**        | `@extend .btn;`                                            | 不支持                                           | 支持                                        |
| **函数 & 运算**   | 强大                                                         | 支持                                            | 支持                                        |
| **条件/循环**     | `@if`,`@for`,`@each`                                       | 有限支持                                          | 支持                                        |
| **社区生态**      | 极丰富（Bootstrap 5+ 使用 SCSS）                                  | 较少                                            | 小众                                        |

### postcss

PostCSS 是一个用 JavaScript 插件转换 CSS 的工具。

它本身不做任何事情，但通过插件可以实现：

- 自动添加浏览器前缀（autoprefixer） ：根据你指定的浏览器兼容范围，自动为 CSS 规则添加必要的厂商前缀（如 -webkit-、-moz-、-ms- 等），确保样式在目标浏览器中正常工作，而无需开发者手动编写冗余代码。

```
/* 手动写前缀（不使用 autoprefixer） */
.container {
  -webkit-display: flex; /* Chrome < 21, Safari < 6.1 */
     -moz-display: flex; /* Firefox < 28 */
      -ms-display: flex; /* IE 10 */
          display: flex;
}
```

Autoprefixer 是一个 PostCSS 插件，它能： 读取你的 CSS 源码，根据你定义的浏览器目标（如 "last 2 versions", "> 1%"），查询 Can I Use 数据库，自动插入必要前缀，删除不必要的旧前缀。

- 使用未来 CSS 语法，如嵌套、自定义媒体查询（postcss-preset-env）：在当前项目中编写尚未被所有浏览器原生支持的 CSS 新特性语法（草案或实验阶段），通过 postcss-preset-env 将其编译为广泛兼容的标准 CSS。

- 支持 CSS Modules：将 CSS 类名自动局部作用域化（scoped）的技术，解决传统 CSS 的全局污染问题（在普通 CSS 中，所有类名都是全局的）。

- 压缩 CSS：移除注释，移除多余空格/换行，缩短颜色值，合并重复规则，简化数值，移除未使用的 CSS，优化属性顺序/结构

- 检查代码风格（stylelint）：检查 CSS 代码风格和潜在错误

- 甚至支持类似 Sass 的功能（通过插件）

PostCSS 之于 CSS，就像 Babel 之于 JavaScript。

除上述以外，常用的插件还包括：

- postcss-import：支持 @import 导入 CSS 文件（类似 Sass 的 @use），原生 CSS 的 @import 是运行时加载，而此插件是构建时合并

- postcss-url：重写 CSS 中的 URL（如转为 base64、CDN 路径等）

- tailwindcss：著名的原子化 CSS 框架

```
PostCSS 本身只处理 .css 文件（或字符串形式的 CSS 内容），它不会直接读取 HTML/JSX/Vue 模板中的 class="..."。

但 Tailwind CSS 通过“扫描源文件 + 动态生成 CSS” 的方式，与 PostCSS 协同工作。
```

- postcss-px-to-viewport：将 CSS 中的 px 单位自动转换为 vw（视口宽度单位）或 vh（视口高度单位），从而实现移动端页面的等比缩放适配。

postcss和css预处理在编译过程中的处理顺序：

```
源码（SCSS / Less / CSS）
       ↓
[预处理器编译] → 将 SCSS/Less 转为标准 CSS
       ↓
[PostCSS 处理] → 对标准 CSS 进行插件转换（autoprefixer、cssnano 等）
       ↓
[编译工具的内部优化] → CSS Modules 哈希、内联/提取、HMR 等
       ↓
最终输出（浏览器可运行的 CSS）
```




