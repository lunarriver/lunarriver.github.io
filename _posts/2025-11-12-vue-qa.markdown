---
layout: post
title:  "Vue Q&A"
date:   2025-11-12 14:04:00 +0800
---

* 目录
  {:toc #markdown-toc}

### ref 与 reactive

| 特性        | `reactive`  | `shallowReactive` | `ref`            | `shallowRef`     |
| --------- | ----------- | ----------------- | ---------------- | ---------------- |
| **响应式深度** | 深度          | 仅根级               | 深度（对象时）          | 仅 `.value`       |
| **支持原始值** | 不支持         | 不支持               | 支持               | 支持               |
| **访问方式**  | `obj.prop`  | `obj.prop`        | `.value`（JS）     | `.value`（JS）     |
| **模板解包**  | N/A         | N/A               | 自动               | 自动               |
| **性能开销**  | 高（深层 Proxy） | 中（仅根级 Proxy）      | 高（对象时同 reactive） | **低**（无嵌套 Proxy） |
| **典型场景**  | 组件状态        | 扁平配置对象            | 通用变量（推荐默认）       | 大对象/实例/优化        |

选用建议：

- `ref` ：最通用、最安全的默认选择；

- `reactive`：管理组件内部复杂状态对象，或需要保持对象引用一致性（传给外部库）；

- `shallowRef`: 存储 ECharts / Three.js / Map 实例，处理 大型静态数据（如 10k 行表格数据），需要 手动控制更新时机（配合 triggerRef）；

- `shallowReactive`：对象是扁平结构（如 { theme: 'dark', lang: 'en' }） ，明确知道不需要嵌套响应式；

`ref`似乎能够覆盖`reactive`，但后者有其不可替代的场景：

| 场景             | 为什么 reactive 更好               |
| -------------- | ----------------------------- |
| 传递对象给外部系统      | 保持引用一致性，自动响应变化                |
| 大型嵌套状态管理       | 避免到处写 `.value`，代码更清晰          |
| 组合式函数返回多个状态    | `toRefs(reactive(...))` 是标准模式 |
| 需要直接操作对象类型（TS） | 类型更干净，无 Ref 包装                |
| 追求最小化响应式开销     | 少一层包装                         |

### Vue-Router中的历史模式

- vue-router-doc: https://router.vuejs.org/zh/guide/essentials/history-mode.html
- Web-History-Api: https://developer.mozilla.org/zh-CN/docs/Web/API/History_API/Working_with_the_History_API

传统上，网站是以页面集合的形式实现的。当用户通过点击链接浏览网站的不同部分时，浏览器每次都会加载一个全新的页面。 虽然这对许多网站来说很好，但也有一些缺点：

- 如果只需要更新页面的一部分，每次加载整个页面的效率会很低
- 跨页面导航时很难保持应用程序状态

由于这些原因，单页应用（SPA）是一种流行的 web 应用程序模式，在这种模式中，网站由一个页面组成，当用户点击链接时，页面会：

- 阻止加载新页面的默认行为
- 获取要显示的新内容
- 用新内容更新页面

问题在于，它破坏了浏览器“后退”和“前进”按钮的预期行为。 从用户的角度来看，他们点击了一个链接，页面就更新了，所以看起来像是一个新页面。如果用户按下浏览器的“后退”按钮，就会返回到点击链接之前的状态。 但在浏览器看来，最后一个链接并没有加载新页面，因此“后退”按钮会将浏览器带回到用户打开 SPA 之前加载的页面。

History Api 的 pushState()、replaceState() 和 popstate 事件所要解决的问题。它们使我们能够合成历史条目，并在当前会话历史条目更改为这些条目之一（例如，由于用户按下了“后退”或“前进”按钮）时收到通知。

- History Api 示例代码：https://github.com/mdn/dom-examples/blob/main/history-api/script.js
- History Api 示例效果：https://mdn.github.io/dom-examples/history-api/vulture

vue-router通过以下形式指定历史模式：

```
import { createRouter, createWebHashHistory, createWebHistory } from 'vue-router'

const router = createRouter({
  // history: createWebHashHistory(),
  // history: createWebHistory(),
  routes: [
    //...
  ],
})
```

`createWebHistory()`即是基于 History Api 实现了不触发页面刷新的前提下的前端路由。

`createWebHashHistory()` 在 URL 上加 #（例如http://example.com/#/home）是为了在不触发页面刷新的前提下实现前端路由，尤其适用于不支持 History API 的环境或无法配置服务器的静态托管场景。

为什么需要加 # ？因为 # 及其后面的部分称为 “fragment identifier”（片段标识符），修改 # 不会向服务器发送新请求，也不会刷新页面，浏览器会触发 hashchange 事件，JavaScript 可监听并响应。

hash模式的工作流程：

![img](../../../assets/vue-router-qa/hash-procedure.png)

两种模式的对比如下：

|           | createWebHashHistory() | createWebHistory()          |
| --------- | ---------------------- | --------------------------- |
| URL 示例    | http://app.com/#/about | http://app.com/about        |
| 是否需要服务器配置 | 不需要                    | 需要（所有路径返回 index.html）       |
| 兼容性       | 支持 IE8+                | 需要 HTML5 History API（IE10+） |
| SEO 友好度   | 较差（传统爬虫可能忽略 # 后内容）     | 更好（标准路径）                    |
| 使用场景      | GitHub Pages、静态托管、老旧环境 | 现代 Web 应用（配合 SSR/正确服务器配置）   |

尽管现代浏览器普遍支持 History API，但 Hash 模式仍有不可替代的优势：

- 零服务器配置：托管在 GitHub Pages、Netlify、Vercel（静态模式）、S3 等平台时，无需设置重定向规则；所有路由请求都指向 index.html，由前端路由接管 
- 兼容老旧系统：企业内网可能仍在使用 IE11 或旧版 WebView ，嵌入式设备浏览器可能不支持 History API
- 避免 404 风险：如果用户直接访问 http://app.com/about（History 模式），但服务器未配置 fallback，会返回 404；Hash 模式下，http://app.com/#/about 始终加载 index.html，前端再处理路由

除了上述两种外，`createMemoryHistory`是 Vue Router 提供的一种特殊路由历史记录模式，它不依赖浏览器的 URL 或 History API，而是将路由状态完全保存在内存中（JavaScript 对象）。它主要用在服务端渲染（SSR）的场景中。（在 Node.js 环境中渲染 Vue 应用时，没有 window、document、history 等浏览器 API）
