---
layout: post
title:  "Vue Q&A"
date:   2025-11-12 14:04:00 +0800
---

* 目录
{:toc #markdown-toc}

### ref 与 reactive

| 特性        | `reactive`  | `shallowReactive` | `ref`            | `shallowRef`     |
| --------- | ----------- | ----------------- | ---------------- | ---------------- |
| **响应式深度** | 深度          | 仅根级               | 深度（对象时）          | 仅`.value`        |
| **支持原始值** | 不支持         | 不支持               | 支持               | 支持               |
| **访问方式**  | `obj.prop`  | `obj.prop`        | `.value`（JS）     | `.value`（JS）     |
| **模板解包**  | N/A         | N/A               | 自动               | 自动               |
| **性能开销**  | 高（深层 Proxy） | 中（仅根级 Proxy）      | 高（对象时同 reactive） | **低**（无嵌套 Proxy） |
| **典型场景**  | 组件状态        | 扁平配置对象            | 通用变量（推荐默认）       | 大对象/实例/优化        |

选用建议：

- `ref`：最通用、最安全的默认选择；

- `reactive`：管理组件内部复杂状态对象，或需要保持对象引用一致性（传给外部库）；

- `shallowRef`: 存储 ECharts / Three.js / Map 实例，处理 大型静态数据（如 10k 行表格数据），需要 手动控制更新时机（配合 triggerRef）；

- `shallowReactive`：对象是扁平结构（如 { theme: 'dark', lang: 'en' }） ，明确知道不需要嵌套响应式；

`ref`似乎能够覆盖`reactive`，但后者有其不可替代的场景：

| 场景             | 为什么 reactive 更好               |
| -------------- | ----------------------------- |
| 传递对象给外部系统      | 保持引用一致性，自动响应变化                |
| 大型嵌套状态管理       | 避免到处写 `.value`，代码更清晰          |
| 组合式函数返回多个状态    | `toRefs(reactive(...))` 是标准模式 |
| 需要直接操作对象类型（TS） | 类型更干净，无 Ref 包装                |
| 追求最小化响应式开销     | 少一层包装                         |

但是，`reactive`也有其局限性：

- 有限的值类型：它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的原始类型。

- 不能替换整个对象：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失。

- 对解构操作不友好：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接。

### 计算属性

`computed()`方法的返回值是一个`ref`，因此，在模板表达式以外的上下文中需要通过`.value`访问其值。

计算属性与方法的区别：一个计算属性仅会在其响应式依赖更新时才重新计算，而方法调用总是会在重渲染发生时再次执行函数。

### 类与样式绑定

对于只有一个根元素的组件，当你使用了 class attribute 时，这些 class 会被添加到根元素上并与该元素上已有的 class 合并。

如果你声明了一个组件名叫 MyComponent，模板如下：

```
<p class="foo bar">Hi!</p>
```

在使用时添加一些 class：

```
<MyComponent class="baz boo" />
```

渲染出的 HTML 为：

```
<p class="foo bar baz boo">Hi!</p>
```

如果你的组件有多个根元素，你将需要指定哪个根元素来接收这个 class。你可以通过组件的`$attrs`属性来指定接收的元素：

```
<!-- MyComponent 模板使用 $attrs 时 -->
<p :class="$attrs.class">Hi!</p>
<span>This is a child component</span>
```

### 列表渲染

Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括: push()、pop()、shift()、unshift()、splice()、sort()、reverse()。

一些不可变 (immutable) 方法，例如 filter()，concat() 和 slice()，这些都不会更改原数组，而总是返回一个新数组，它们不会触发相关的更新。

### 事件处理

在处理事件时调用 event.preventDefault() 或 event.stopPropagation() 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。

为解决这一问题，Vue 为 v-on 提供了事件修饰符。修饰符是用 . 表示的指令后缀，包含：`.stop`、`.prevent`、`.self`、`.capture`、`.once`、`.passive`。

```
<!-- 单击事件将停止传递 -->
<a @click.stop="doThis"></a>

<!-- 提交事件将不再重新加载页面 -->
<form @submit.prevent="onSubmit"></form>

<!-- 修饰语可以使用链式书写 -->
<a @click.stop.prevent="doThat"></a>

<!-- 也可以只有修饰符 -->
<form @submit.prevent></form>

<!-- 仅当 event.target 是元素本身时才会触发事件处理器 -->
<!-- 例如：事件处理器不来自子元素 -->
<div @click.self="doThat">...</div>
```

### 表单输入绑定

默认情况下，v-model 会在每次 input 事件后更新数据 (IME 拼字阶段的状态例外)。你可以添加 lazy 修饰符来改为在每次 change 事件后更新数据：

```
<!-- 在 "change" 事件后同步更新而不是 "input" -->
<input v-model.lazy="msg" />
```

input 事件在值变化时立即触发。change 事件在以下情况下触发。

| input 类型                 | 触发条件                 |
|--------------------------| -------------------- |
| `text`/`number`/`email`等 | 值改变 + 失去焦点（blur）     |
| `checkbox`/`radio`       | 点击切换状态时立即触发（无需 blur） |
| `select`                 | 选择新选项时立即触发           |
| `range`                  | 拖动结束松开鼠标时触发          |
| `file`                   | 选择文件后立即触发            |

如果你想让用户输入自动转换为数字，你可以在 v-model 后添加 .number 修饰符来管理输入：

```
<input v-model.number="age" />
```

如果该值无法被 parseFloat() 处理，那么将返回原始值。特别是当输入为空时 (例如用户清空输入字段之后)，会返回一个空字符串。number 修饰符会在输入框有 type="number" 时自动启用。

如果你想要默认自动去除用户输入内容中两端的空格，你可以在 v-model 后添加 .trim 修饰符：

```
<input v-model.trim="msg" />
```

### 侦听器

**watchEffect()**

下面的代码，在每当 todoId 的引用发生变化时使用侦听器来加载一个远程资源：

```
const todoId = ref(1)
const data = ref(null)

watch(
  todoId,
  async () => {
    const response = await fetch(
      `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
    )
    data.value = await response.json()
  },
  { immediate: true }
)
```

特别是注意侦听器是如何两次使用 todoId 的，一次是作为源，另一次是在回调中。

我们可以用 watchEffect 函数 来简化上面的代码。watchEffect() 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：

```
watchEffect(async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
})
```

这个例子中，回调会立即执行，不需要指定 immediate: true。在执行期间，它会自动追踪 todoId.value 作为依赖(和计算属性类似)。每当 todoId.value 变化时，回调会再次执行。

对于这种只有一个依赖项的例子来说，watchEffect() 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 watchEffect() 可以消除手动维护依赖列表的负担。

**onWatcherCleanup()**

有时我们可能会在侦听器中执行副作用，例如异步请求：

```
watch(id, (newId) => {
  fetch(`/api/${newId}`).then(() => {
    // 回调逻辑
  })
})
```

但是如果在请求完成之前 id 发生了变化怎么办？当上一个请求完成时，它仍会使用已经过时的 ID 值触发回调。理想情况下，我们希望能够在 id 变为新值时取消过时的请求。

我们可以使用 onWatcherCleanup()  API 来注册一个清理函数，当侦听器失效并准备重新运行时会被调用：

```
import { watch, onWatcherCleanup } from 'vue'

watch(id, (newId) => {
  const controller = new AbortController()

  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {
    // 回调逻辑
  })

  onWatcherCleanup(() => {
    // 终止过期请求
    controller.abort()
  })
})
```

**回调的触发时机**

默认情况下，侦听器回调会在父组件更新 (如有) 之后、所属组件的 DOM 更新之前被调用。这意味着如果你尝试在侦听器回调中访问所属组件的 DOM，那么 DOM 将处于更新前的状态。

如果想在侦听器回调中能访问被 Vue 更新之后的所属组件的 DOM，你需要指明 flush: 'post' 选项：

```
watch(source, callback, {
  flush: 'post'
})

watchEffect(callback, {
  flush: 'post'
})
```

你还可以创建一个同步触发的侦听器，它会在 Vue 进行任何更新之前触发：

```
watch(source, callback, {
  flush: 'sync'
})

watchEffect(callback, {
  flush: 'sync'
})
```

### 模板引用

**useTemplateRef()**

```
<script setup>
import { useTemplateRef, onMounted } from 'vue'

// 声明一个模板引用，名称必须与模板中 ref="inputEl" 一致
const inputEl = useTemplateRef('inputEl')

onMounted(() => {
  // inputEl 自动指向 <input> DOM 元素
  inputEl.value?.focus()
})
</script>

<template>
  <!-- ref 名称必须与 useTemplateRef 的参数一致 -->
  <input ref="inputEl" />
</template>
```

相对于原始的 ref 形式，useTemplateRef 具有以下特性：

- useTemplateRef('xxx') 返回的是 shallowRef，因为 DOM 元素/组件实例本身不需要深层响应式，而普通 ref(null) 是深度响应式；

- useTemplateRef 的值严格与 DOM 更新同步，而普通 ref 只是个容器，不会主动监听 DOM 变化；

- Vue 编译器能识别 useTemplateRef('xxx')，自动建立模板 ref="xxx" 与该变量的绑定，并提供更好的 TypeScript 类型推导，而普通 ref(null) 需要手动标注类型；

- useTemplateRef 强制要求名称匹配，减少拼写错误，而普通 ref 无法检测；

**v-for 中的模板引用**

当在 v-for 中使用模板引用时，对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素：

```
<script setup>
import { ref, useTemplateRef, onMounted } from 'vue'

const list = ref([
  /* ... */
])

const itemRefs = useTemplateRef('items')

onMounted(() => console.log(itemRefs.value))
</script>

<template>
  <ul>
    <li v-for="item in list" ref="items">
      {{ item }}
    </li>
  </ul>
</template>
```

**函数模板引用**

除了使用字符串值作名字，ref attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数：

```
<input :ref="(el) => { /* 将 el 赋值给一个数据属性或 ref 变量 */ }">
```

useTemplateRef 不能用于函数式 ref。

### 组件 Props

**更改对象 / 数组类型的 props**

当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但**仍然可以更改**对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，对 Vue 来说，阻止这种更改需要付出的代价异常昂贵。

这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。在大多数场景下，子组件应该抛出一个事件来通知父组件做出改变。

**属性的默认值**

除 Boolean 外的未传递的可选 prop 将会有一个默认值 undefined。 Boolean 类型的未传递 prop 将被转换为 false。

### 组件 v-model

**props + emit 的实现方式**

```
// Child.vue
<script setup>
const props = defineProps(['modelValue'])
const emit = defineEmits(['update:modelValue'])
</script>

<template>
  <input
    :value="props.modelValue"
    @input="emit('update:modelValue', $event.target.value)"
  />
</template>
```

```
// Parent.vue
<Child
  :modelValue="foo"
  @update:modelValue="$event => (foo = $event)"
/>
```

**defineModel()**

defineModel 是一个便利宏。编译器将其展开为以下内容：

- 一个名为 modelValue 的 prop，本地 ref 的值与其同步；

- 一个名为 update:modelValue 的事件，当本地 ref 的值发生变更时触发；

```
// Child.vue
<script setup>
const model = defineModel()

function update() {
  model.value++
}
</script>

<template>
  <div>Parent bound v-model is: {{ model }}</div>
  <button @click="update">Increment</button>
</template>
```

```
// Parent.vue
<Child v-model="countModel" />
```

defineModel() 返回的值是一个 ref。它可以像其他 ref 一样被访问以及修改，不过它能起到在父组件和当前变量之间的双向绑定的作用：

- 它的 .value 和父组件的 v-model 的值同步； 

- 当它被子组件变更了，会触发父组件绑定的值一起更新；

你也可以用 v-model 把这个 ref 绑定到一个原生 input 元素上，在提供相同的 v-model 用法的同时轻松包装原生 input 元素：

```
<script setup>
const model = defineModel()
</script>

<template>
  <input v-model="model" />
</template>
```

**多个 v-model 绑定**

```
<UserName
  v-model:first-name="first"
  v-model:last-name="last"
/>
```

```
<script setup>
const firstName = defineModel('firstName')
const lastName = defineModel('lastName')
</script>

<template>
  <input type="text" v-model="firstName" />
  <input type="text" v-model="lastName" />
</template>
```

### 组件透传 Attributes

“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id。

当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。举例来说，假如我们有一个 `<MyButton>` 组件，它的模板长这样：

```
<!-- <MyButton> 的模板 -->
<button>Click Me</button>
```

一个父组件使用了这个组件，并且传入了 class：

```
<MyButton class="large" />
```

最后渲染出来的结果是：

```
<button class="large">Click Me</button>
```

如果一个子组件的根元素已经有了 class 或 style attribute，它会和从父组件上继承的值合并。

同样的规则也适用于 v-on 事件监听器：

```
<MyButton @click="onClick" />
```

click 监听器会被添加到 `<MyButton>` 的根元素，即那个原生的 `<button>` 元素之上。当原生的 `<button>` 被点击，会触发父组件的 onClick 方法。同样的，如果原生 button 元素自身也通过 v-on 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。

**透传 Attributes 的精细控制**

如果你不想要一个组件自动地继承 attribute，你可以在组件选项中设置 inheritAttrs: false。

```
<script setup>
defineOptions({
  inheritAttrs: false
})
// ...setup 逻辑
</script>
```

最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 inheritAttrs 选项为 false，你可以完全控制透传进来的 attribute 被如何使用。

这些透传进来的 attribute 可以在模板的表达式中直接用 $attrs 访问到。

```
<span>Fallthrough attribute: {{ $attrs }}</span>
```

**在 JavaScript 中访问透传 Attributes**

如果需要，你可以在 `<script setup>` 中使用 useAttrs() API 来访问一个组件的所有透传 attribute：

```
<script setup>
import { useAttrs } from 'vue'

const attrs = useAttrs()
</script>
```

### 组件插槽

**默认内容**

如果我们想在父组件没有提供任何插槽内容时在 `<button>` 内渲染“Submit”，只需要将“Submit”写在 `<slot>` 标签之间来作为默认内容：

```
<button type="submit">
  <slot>
    Submit <!-- 默认内容 -->
  </slot>
</button>
```

**具名插槽**

`<slot>` 元素可以有一个特殊的 attribute name，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容：

```
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

要为具名插槽传入内容，我们需要使用一个含 v-slot 指令的 `<template>` 元素，并将目标插槽的名字传给该指令：

```
<BaseLayout>
  <template v-slot:header>
    <!-- header 插槽的内容放这里 -->
  </template>
</BaseLayout>
```

v-slot 有对应的简写 #，因此 `<template v-slot:header>` 可以简写为 `<template #header>`。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。

**条件插槽**

有时你需要根据内容是否被传入了插槽来渲染某些内容。 你可以结合使用 $slots 属性与 v-if 来实现。

```
<template>
  <div class="card">
    <div v-if="$slots.header" class="card-header">
      <slot name="header" />
    </div>
    
    <div v-if="$slots.default" class="card-content">
      <slot />
    </div>
    
    <div v-if="$slots.footer" class="card-footer">
      <slot name="footer" />
    </div>
  </div>
</template>
```

**作用域插槽**

默认情况下，插槽的内容无法访问到子组件的状态。然而在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。

要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。

可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes：

```
<!-- <MyComponent> 的模板 -->
<div>
  <slot :text="greetingMessage" :count="1"></slot>
</div>
```

默认插槽通过子组件标签上的 v-slot 指令，直接接收到了一个插槽 props 对象：

```
<MyComponent v-slot="slotProps">
  {{ slotProps.text }} {{ slotProps.count }}
</MyComponent>
```

具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 v-slot 指令的值被访问到：v-slot:name="slotProps"。

```
<MyComponent>
  <template #header="headerProps">
    {{ headerProps }}
  </template>

  <template #default="defaultProps">
    {{ defaultProps }}
  </template>

  <template #footer="footerProps">
    {{ footerProps }}
  </template>
</MyComponent>
```

### 组件依赖注入

Props 逐级透传问题：有一些多层级嵌套的组件，形成了一棵巨大的组件树，而某个深层的子组件需要一个较远的祖先组件中的部分数据。中间组件可能根本不关心这些数据，但为了使深层的子组件能访问到它们，仍然需要定义并向下传递。

provide 和 inject 可以帮助解决 Props 逐级透传问题。

要为组件后代提供数据，需要使用到 provide() 函数：

```
<script setup>
import { provide } from 'vue'

provide(/* 注入名 */ 'message', /* 值 */ 'hello!')
</script>
```

要注入上层组件提供的数据，需使用 inject() 函数：

```
<script setup>
import { inject } from 'vue'

const message = inject('message')
</script>
```

**注入默认值**

```
// 如果没有祖先组件提供 "message"
// `value` 会是 "这是默认值"
const value = inject('message', '这是默认值')
```

**和响应式数据配合使用**

```
<!-- 在供给方组件内 -->
<script setup>
import { provide, ref } from 'vue'

const location = ref('North Pole')

function updateLocation() {
  location.value = 'South Pole'
}

provide('location', {
  location,
  updateLocation
})
</script>
```

```
<!-- 在注入方组件 -->
<script setup>
import { inject } from 'vue'

const { location, updateLocation } = inject('location')
</script>

<template>
  <button @click="updateLocation">{{ location }}</button>
</template>
```

**使用 Symbol 作注入名**

如果存在非常多的依赖提供，或者你正在编写提供给其他开发者使用的组件库，建议最好使用 Symbol 来作为注入名以避免潜在的冲突。

```
// key.js
export const myInjectionKey = Symbol()
```

```
// Provide组件
import { provide } from 'vue'
import { myInjectionKey } from './keys.js'

provide(myInjectionKey, { 
  /* 要提供的数据 */
})
```

```
// Inject组件
import { inject } from 'vue'
import { myInjectionKey } from './keys.js'

const injected = inject(myInjectionKey)
```

### 异步组件

在大型项目中，我们可能需要拆分应用为更小的块，Vue 提供了 defineAsyncComponent 方法来实现此功能：

```
import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent(() =>
  import('./components/MyComponent.vue')
)
```

ES 模块动态导入也会返回一个 Promise，所以多数情况下我们会将它和 defineAsyncComponent 搭配使用。

最后得到的 AsyncComp 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。

异步操作不可避免地会涉及到加载和错误状态，因此 defineAsyncComponent() 也支持在高级选项中处理这些状态：

```
const AsyncComp = defineAsyncComponent({
  // 加载函数
  loader: () => import('./Foo.vue'),

  // 加载异步组件时使用的组件
  loadingComponent: LoadingComponent,
  // 展示加载组件前的延迟时间，默认为 200ms
  delay: 200,

  // 加载失败后展示的组件
  errorComponent: ErrorComponent,
  // 如果提供了一个 timeout 时间限制，并超时了
  // 也会显示这里配置的报错组件，默认值是：Infinity
  timeout: 3000
})
```

在纯客户端应用中，异步组件的主要作用是：

- 代码分割：将组件打包成独立的 JS chunk，按需加载，而不是一次性加载所有代码。进而可以实现——初始包体积更小（首屏加载更快） ；按需加载，节省带宽；未访问的功能不会被下载；

- 性能优化：避免阻塞主包，进而实现主应用秒开（加载较慢的组件采用异步加载），只有用户真正需要时才加载重型组件；

- 渐进式加载的用户体验：显示加载状态，避免白屏；建立错误边界，增强健壮性；用户感知更流畅；

- 功能模块化：大型应用架构的基础，团队分工更清晰（不同模块独立开发），部署更灵活（可单独更新模块），缓存更高效（小 chunk 更新不影响大 chunk）；

纯客户端中的异步组件典型用法：

- 路由懒加载（最常见）

```
const routes = [
  {
    path: '/profile',
    component: () => import('./views/Profile.vue')
  }
]
```

- 功能模块懒加载

```
<script setup>
const AdvancedEditor = defineAsyncComponent(() => 
  import('./AdvancedEditor.vue')
)
</script>
```

- 条件渲染优化

```
<script setup>
const ChartModule = defineAsyncComponent(() => 
  import('./ChartModule.vue')
)

const showChart = computed(() => userPreferences.showChart)
</script>

<template>
  <ChartModule v-if="showChart" />
</template>
```

- 第三方库封装

```
<script setup>
// 封装重型第三方库
const MonacoEditor = defineAsyncComponent(async () => {
  // 可以添加额外逻辑
  await import('monaco-editor/min/vs/editor/editor.main.css')
  return import('./MonacoEditor.vue')
})
</script>
```

### 组合式函数

“组合式函数”(Composables) 是一个利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数。

```
import { ref, watchEffect, toValue } from 'vue'

export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)

  const fetchData = () => {
    // reset state before fetching..
    data.value = null
    error.value = null

    fetch(toValue(url))
      .then((res) => res.json())
      .then((json) => (data.value = json))
      .catch((err) => (error.value = err))
  }

  watchEffect(() => {
    fetchData()
  })

  return { data, error }
}
```

toValue()将 ref 或 getter 规范化为值。如果参数是 ref，它会返回 ref 的值；如果参数是函数，它会调用函数并返回其返回值。否则，它会原样返回参数。

watchEffect()立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。

toValue(url) 是在 watchEffect 回调函数的内部调用的。这确保了在 toValue() 规范化期间访问的任何响应式依赖项都会被侦听器跟踪。

约定和最佳实践：

- 组合式函数约定用驼峰命名法命名，并以“use”作为开头。

- 输入参数：即便不依赖于 ref 或 getter 的响应性，组合式函数也可以接收它们作为参数。亦即，总是使用toValue()取得输入值。

- 组合式函数始终返回一个包含多个 ref 的普通的非响应式对象，这样该对象在组件中被解构为 ref 之后仍可以保持响应性。

- 在组合式函数中的确可以执行副作用，但需要确保在 onUnmounted() 时清理副作用。

- 组合式函数只能在 `<script setup>` 或 setup() 钩子中被调用。在这些上下文中，它们也只能被同步调用。这些限制很重要，因为这些是 Vue 用于确定当前活跃的组件实例的上下文。访问活跃的组件实例很有必要，这样才能： 将生命周期钩子注册到该组件实例上；将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。

### 自定义指令

自定义指令主要是为了重用涉及普通元素的底层 DOM 访问的逻辑。

一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。钩子函数会接收到指令所绑定元素作为其参数。

```
<script setup>
// 在模板中启用 v-highlight
const vHighlight = {
  mounted: (el) => {
    el.classList.add('is-highlight')
  }
}
</script>

<template>
  <p v-highlight>This sentence is important!</p>
</template>
```

### 插件

插件 (Plugins) 是一种能为 Vue 添加全局功能的工具代码。下面是如何安装一个插件的示例：

```
import { createApp } from 'vue'

const app = createApp({})

app.use(myPlugin, {
  /* 可选的选项 */
})
```

一个插件可以是一个拥有 install() 方法的对象，也可以直接是一个安装函数本身。安装函数会接收到安装它的应用实例和传递给 app.use() 的额外选项作为参数：

```
const myPlugin = {
  install(app, options) {
    // 配置此应用
  }
}
```

插件没有严格定义的使用范围，但是插件发挥作用的常见场景主要包括以下几种：

- 通过 app.component() 和 app.directive() 注册一到多个全局组件或自定义指令。

- 通过 app.provide() 使一个资源可被注入进整个应用。

- 向 app.config.globalProperties 中添加一些全局实例属性或方法

- 一个可能上述三种都包含了的功能库 (例如 vue-router)。

### KeepAlive

`<KeepAlive>` 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。

```
<component :is="activeComponent" />
```

默认情况下，一个组件实例在被替换掉后会被销毁。这会导致它丢失其中所有已变化的状态——当这个组件再一次被显示时，会创建一个只带有初始状态的新实例。

可以用 `<KeepAlive>` 内置组件将这些动态组件包装起来：

```
<!-- 非活跃的组件将会被缓存！ -->
<KeepAlive>
  <component :is="activeComponent" />
</KeepAlive>
```

`<KeepAlive>` 默认会缓存内部的所有组件实例，但我们可以通过 include 和 exclude prop 来定制该行为。

```
<KeepAlive :include="['a', 'b']">
  <component :is="view" />
</KeepAlive>
```

可以通过传入 max prop 来限制可被缓存的最大组件实例数。`<KeepAlive>` 的行为在指定了 max 后类似一个 LRU 缓存。

```
<KeepAlive :max="10">
  <component :is="activeComponent" />
</KeepAlive>
```

当一个组件实例从 DOM 上移除但因为被 `<KeepAlive>` 缓存而仍作为组件树的一部分时，它将变为不活跃状态而不是被卸载。当一个组件实例作为缓存树的一部分插入到 DOM 中时，它将重新被激活。

一个持续存在的组件可以通过 onActivated() 和 onDeactivated() 注册相应的两个状态的生命周期钩子：

```
<script setup>
import { onActivated, onDeactivated } from 'vue'

onActivated(() => {
  // 调用时机为首次挂载
  // 以及每次从缓存中被重新插入时
})

onDeactivated(() => {
  // 在从 DOM 上移除、进入缓存
  // 以及组件卸载时调用
})
</script>
```

### Teleport

`<Teleport>` 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。

它用于解决这样的问题：一个组件模板的一部分在逻辑上从属于该组件，但从整个应用视图的角度来看，它在 DOM 中应该被渲染在其他地方，甚至在整个 Vue 应用外部。

这类场景最常见的例子就是全屏的模态框。

```
<button @click="open = true">Open Modal</button>

<Teleport to="body">
  <div v-if="open" class="modal">
    <p>Hello from the modal!</p>
    <button @click="open = false">Close</button>
  </div>
</Teleport>
```

`<Teleport>` 接收一个 to prop 来指定传送的目标。to 的值可以是一个 CSS 选择器字符串，也可以是一个 DOM 元素对象。这段代码的作用就是告诉 Vue“把以下模板片段传送到 body 标签下”。

### 单文件组件是如何工作的

Vue 单文件组件是一个框架指定的文件格式，因此必须交由 @vue/compiler-sfc 编译为标准的 JavaScript 和 CSS，一个编译后的单文件组件是一个标准的 JavaScript(ES) 模块，这也意味着在构建配置正确的前提下，你可以像导入其他 ES 模块一样导入单文件组件：

```
import MyComponent from './MyComponent.vue'

export default {
  components: {
    MyComponent
  }
}
```

单文件组件中的 `<style>` 标签一般会在开发时注入成原生的 `<style>` 标签以支持热更新，而生产环境下它们会被抽取、合并成单独的 CSS 文件。

### Vue-Router中的历史模式

- vue-router-doc: https://router.vuejs.org/zh/guide/essentials/history-mode.html
- Web-History-Api: https://developer.mozilla.org/zh-CN/docs/Web/API/History_API/Working_with_the_History_API

传统上，网站是以页面集合的形式实现的。当用户通过点击链接浏览网站的不同部分时，浏览器每次都会加载一个全新的页面。 虽然这对许多网站来说很好，但也有一些缺点：

- 如果只需要更新页面的一部分，每次加载整个页面的效率会很低
- 跨页面导航时很难保持应用程序状态

由于这些原因，单页应用（SPA）是一种流行的 web 应用程序模式，在这种模式中，网站由一个页面组成，当用户点击链接时，页面会：

- 阻止加载新页面的默认行为
- 获取要显示的新内容
- 用新内容更新页面

问题在于，它破坏了浏览器“后退”和“前进”按钮的预期行为。 从用户的角度来看，他们点击了一个链接，页面就更新了，所以看起来像是一个新页面。如果用户按下浏览器的“后退”按钮，就会返回到点击链接之前的状态。 但在浏览器看来，最后一个链接并没有加载新页面，因此“后退”按钮会将浏览器带回到用户打开 SPA 之前加载的页面。

History Api 的 pushState()、replaceState() 和 popstate 事件所要解决的问题。它们使我们能够合成历史条目，并在当前会话历史条目更改为这些条目之一（例如，由于用户按下了“后退”或“前进”按钮）时收到通知。

- History Api 示例代码：https://github.com/mdn/dom-examples/blob/main/history-api/script.js
- History Api 示例效果：https://mdn.github.io/dom-examples/history-api/vulture

vue-router通过以下形式指定历史模式：

```
import { createRouter, createWebHashHistory, createWebHistory } from 'vue-router'

const router = createRouter({
  // history: createWebHashHistory(),
  // history: createWebHistory(),
  routes: [
    //...
  ],
})
```

`createWebHistory()`即是基于 History Api 实现了不触发页面刷新的前提下的前端路由。

`createWebHashHistory()` 在 URL 上加 #（例如http://example.com/#/home）是为了在不触发页面刷新的前提下实现前端路由，尤其适用于不支持 History API 的环境或无法配置服务器的静态托管场景。

为什么需要加 # ？因为 # 及其后面的部分称为 “fragment identifier”（片段标识符），修改 # 不会向服务器发送新请求，也不会刷新页面，浏览器会触发 hashchange 事件，JavaScript 可监听并响应。

hash模式的工作流程：

![img](../../../assets/vue-router-qa/hash-procedure.png)

两种模式的对比如下：

|           | createWebHashHistory() | createWebHistory()          |
| --------- | ---------------------- | --------------------------- |
| URL 示例    | http://app.com/#/about | http://app.com/about        |
| 是否需要服务器配置 | 不需要                    | 需要（所有路径返回 index.html）       |
| 兼容性       | 支持 IE8+                | 需要 HTML5 History API（IE10+） |
| SEO 友好度   | 较差（传统爬虫可能忽略 # 后内容）     | 更好（标准路径）                    |
| 使用场景      | GitHub Pages、静态托管、老旧环境 | 现代 Web 应用（配合 SSR/正确服务器配置）   |

尽管现代浏览器普遍支持 History API，但 Hash 模式仍有不可替代的优势：

- 零服务器配置：托管在 GitHub Pages、Netlify、Vercel（静态模式）、S3 等平台时，无需设置重定向规则；所有路由请求都指向 index.html，由前端路由接管 
- 兼容老旧系统：企业内网可能仍在使用 IE11 或旧版 WebView ，嵌入式设备浏览器可能不支持 History API
- 避免 404 风险：如果用户直接访问 http://app.com/about（History 模式），但服务器未配置 fallback，会返回 404；Hash 模式下，http://app.com/#/about 始终加载 index.html，前端再处理路由

除了上述两种外，`createMemoryHistory`是 Vue Router 提供的一种特殊路由历史记录模式，它不依赖浏览器的 URL 或 History API，而是将路由状态完全保存在内存中（JavaScript 对象）。它主要用在服务端渲染（SSR）的场景中。（在 Node.js 环境中渲染 Vue 应用时，没有 window、document、history 等浏览器 API）

### 在组件外使用 Pinia Store

Pinia store 依靠 pinia 实例在所有调用中共享同一个 store 实例。大多数时候，只需调用你定义的 useStore() 函数，完全开箱即用。但在组件之外，情况就有点不同了。 实际上，useStore() 给你的 app 自动注入了 pinia 实例。这意味着，如果 pinia 实例不能自动注入，你必须手动提供给 useStore() 函数。

对于单页面应用（SPA），在用 app.use(pinia) 安装 pinia 插件后，对 useStore() 的任何调用都会正常执行：

```
import { useUserStore } from '@/stores/user'
import { createPinia } from 'pinia'
import { createApp } from 'vue'
import App from './App.vue'

// 失败，因为它是在创建 pinia 之前被调用的
const userStore = useUserStore()

const pinia = createPinia()
const app = createApp(App)
app.use(pinia)

// 成功，因为 pinia 实例现在激活了
const userStore = useUserStore()
```

当处理服务端渲染时，你将必须把 pinia 实例传递给 useStore()。